# 计算机网络

## 参考资料


## 目录

* [1. socket什么情况下可读或可写？](#-socket什么情况下可读或可写？)
* [2. udp调用connect有什么作用？](#-udp调用connect有什么作用？)


## socket什么情况下可读或可写？

可读:
1. socket接收缓冲区中已经接收的数据的字节数大于等于socket`接收缓冲区低水位标记`的当前值;对这样的socket的读操作不会阻塞,并返回一个大于0的值(准备好读入的数据的字节数). 
2. 连接的读半部关闭(即:接收到对方发过来的FIN的TCP连接),并且返回0;  
3. socket为监听套接字且收到了对方的connect请求已经完成的连接数为非0.这样的soocket处于可读状态；  
4. 存在一个套接字错误待处理，这时socket的读操作将不会阻塞,并且返回一个错误(-1)。

可写:
 1. socket发送缓冲区中的可用空间字节数大于等于socket`发送缓冲区低水位标记`的当前值,且(i):socket已连接(TCP socket),或者(ii):socket不要求连接(如:UDP socket).这意味着,如果我们将这样的socket设置为非阻塞模式,写操作将不会阻塞,并且返回一个正值(如:由传输层接收的字节数).我们可以用socket选项SO_SNDLOWAT来设置此低水位标记,对于TCP和UDP socket,其缺省值一般是2048Bytes; 
 2. 连接的写半部关闭.对于这样的socket的的写操作将产生信号SIGPIPE; 
 3. 使用非阻塞式connect的套接字已经建立连接，或connect已经以失败告终；
 4. 存在一个套接字错误待处理.对于这样的socket的写操作将不会阻塞并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可以通过指定socket选项SO_ERROR调用getsockopt函数来取得并清除。

## udp调用connect有什么作用？

1. 因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用`sendto()/recvfrom()时都必须指定目标IP和端口号`。通过调用connect()建立一个端到端的连接，就可以和TCP一样使用send()/recv()传递数据，而不需要每次都指定目标IP和端口号。但是它和TCP不同的是它没有三次握手的过程。
2. 可以通过在已建立连接的UDP套接字上，调用connect()实现指定新的IP地址和端口号以及断开连接。




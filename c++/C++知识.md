# C++知识

## 参考资料

* [算力网络](https://wenku.baidu.com/view/33f69eded2d233d4b14e852458fb770bf78a3be9.html)


## 概念

TortoiseGit小乌龟 + git 实现版本管理

* [1. 基类析构函数为什么要定义为虚函数？](#-基类析构函数为什么要定义为虚函数？)
* [2. 深拷贝和浅拷贝](#-深拷贝和浅拷贝)
* [3. new与malloc有什么区别？](#-new与malloc有什么区别？)
* [4. C++重载、重定义、重写的区别](#-C++重载、重定义、重写的区别)
* [5. 构造函数和析构函数能否重载？](#-构造函数和析构函数能否重载？)
* [6. c++如何避免内存泄漏](#-c++如何避免内存泄漏)
* [7. const](#-const)
* [8. C++中指针和引用的区别](#-C++中指针和引用的区别)
* [9. 拷贝构造函数的参数类型必须是引用](#-拷贝构造函数的参数类型必须是引用)
* [10. 为什么内联函数，构造函数，静态成员函数不能为virtual函数？](#-为什么内联函数，构造函数，静态成员函数不能为virtual函数？)

## C++问题记录

## 基类析构函数为什么要定义为虚函数？

- 当基类指针指向派生类时，若基类析构函数不声明为虚函数，则析构时，只会调用基类而不会调用派生类的析构函数，从而导致内存泄漏。

## 构造函数不可能为虚函数

- 如果构造函数是虚函数，则需要通过vptr执行那个vtable(存储在对象的内存空间的)，可是对象还没有实例化，
也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。

备注: 当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。
虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，
每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。

## 深拷贝和浅拷贝

- 深拷贝(Memberwise copy semantics)是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。

- 浅拷贝(bitwise copy semantics)是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。

- 浅拷贝在类里面有指针成员的情况下只会复制指针的地址，会导致两个成员指针指向同一块内存，这样在要是分别delete释放时就会出现问题，因此需要用深拷贝。

如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的浅拷贝。
举例如下: 
如果CA(const CA& C) 中没有使用str=new char[a]进行深拷贝，return 0的时候，调用B的析构函数释放char *str的内容，再次调用A的析构函数就会
报错。
```c++
#include <iostream>
using namespace std;
class CA
{
　public:
　　CA(int b,char* cstr)
　　{
　　　a=b;
　　　str=new char[b];
　　　strcpy(str,cstr);
　　}
　　CA(const CA& C)
　　{
　　　a=C.a;
　　　str=new char[a]; //深拷贝 str = C.str则为浅拷贝
　　　if(str!=NULL)
　　　　strcpy(str,C.str);
　　}
　　void Show()
　　{
　　　cout<<str<<endl;
　　}
　　~CA()
　　{
　　　delete str;
　　}
　private:
　　int a;
　　char *str;
};

int main()
{
　CA A(10,"Hello!");
　CA B=A;
　B.Show();
　return 0;
} 

```

## new与malloc有什么区别？

- 申请的内存所在位置: new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
- 返回类型安全性: new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- 内存分配失败时的返回值: new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
```
int *a  = (int *)malloc ( sizeof (int ));
if(NULL == a)
{
    ...
}
else 
{
    ...
}

try
{
    int *a = new int();
}
catch (bad_alloc)
{
    ...
}
```
- 是否需要指定内存大小: 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
- 是否调用构造函数/析构函数: new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。
- 对数组的处理: C++提供了new[]与delete[]来专门处理数组类型,malloc，它并知道你在这块内存上要放的数组还是啥别的东西，
反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小。
```
A * ptr = new A[10];//分配10个A对象
delete [] ptr;

int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
```
- new与malloc是否可以相互调用: operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。
- 是否可以被重载: opeartor new /operator delete可以被重载。malloc/free并不允许重载。
- 能够直观地重新分配内存: 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。
realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，
先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。new没有这样直观的配套设施来扩充内存。
- 客户处理内存分配不足: 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。
对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。

总结: 

特征 | new/delete | malloc/free
---|---|---
分配内存的位置|自由存储区|堆
内存分配成功的返回值|完整类型指针|void*
内存分配失败的返回值|默认抛出异常|返回NULL
分配内存的大小|由编译器根据类型计算得出|必须显式指定字节数
已分配内存的扩充|无法直观地处理|使用realloc简单完成
分配内存时内存不足|客户能够指定处理函数或重新制定分配器|无法通过用户代码进行处理
处理数组|有处理数组的new版本new[]|需要用户计算数组的大小后进行内存分配
是否相互调用|可以,看具体的operator new/delete实现|不可调用new
函数重载|允许|不允许
构造函数与析构函数|调用|不调用

## C++重载、重定义、重写的区别

- 重载
```
1. 在同一个作用域下，函数名相同，函数的参数不同（参数不同指参数的类型或参数的个数不相同，const和非const）
2. 不能根据返回值判断两个函数是否构成重载。
3. 当函数构成重载后，调用该函数时，编译器会根据函数的参数选择合适的函数进行调用。
4. 构成重载的例子: 
int Add( int a , int b )
double Add( double a , double b )
```

- 重定义（隐藏）
```
1. 在不同的作用域下（这里不同的作用域指一个在子类，一个在父类 ），函数名相同的两个函数构成重定义。
2. 当两个函数构成重定义时，父类的同名函数会被隐藏，当用子类的对象调用同名的函数时，如果不指定类作用符，就只会调用子类的同名函数。
3. 如果想要调用父类的同名函数，就必须指定父类的域作用符。
注意: 当父类和子类的成员变量名相同时，也会构成隐藏。

```

```c++
class A
{
public :
       void fun1( char c )
      {
           cout << "A::fun1()" << endl;
      }
       int _a;
};
class B : public A
{
public :
       void fun1( int a , int b )
      {
           cout << "B::fun1()" << endl;
      }
       int _b;
};
int main()
{
      B b;
      b.fun1( 'a' );
      system( "pause" );//b.A::fun1();
      return 0;
}
```

- 重写（覆盖）

```
1.在不同的作用域下（一个在父类，一个在子类），函数的函数名、参数、返回值完全相同，父类必须含有virtual关键字（协变除外）。
2.什么是协变？
（1）函数的函数名相同，参数也相同，但是函数的返回值可以不同（但必须只能是一个返回父类的指针（或引用）一个返回子类的指针（或引用），父类必须含有virtual关键字。
（2）构成协变的一种方式，返回指针；
```

## 构造函数和析构函数能否重载？

- 函数重载就是同一函数名的不同实现，并且能在编译时能与一具体形式匹配，这样参数列表必须不一样。由于重载函数与普通函数的差别是没有返回值，而返回值不能确定函数重载，所以构造函数可以重载；析构函数的特点是参数列表为空，并且无返回值，从而不能重载。

## c++如何避免内存泄漏
```
1. 使用RAII(ResourceAcquisition Is Initialization,资源获取即初始化)技法，以构造函数获取资源(内存),析构函数释放。
2. 相比于使用原生指针，更建议使用智能指针，尤其是C++11标准化后的智能指针，例如share_ptr。
3. 注意new/delete和new[]/delete[]的使用方法。
4. 类的copy constructor函数，可能造成内存泄漏，当原始对象中有动态分配的成员变量时，默认copy constructor函数会采用浅拷贝，
从而导致析构时，同一个资源被释放两次
```
## const

#### 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针和指针常量；
3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。因为const函数中的*this是常量，同样只能访问const函数；

#### 使用

const 使用

```cpp
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 常指针
    const A &q = a;             // 常引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量
    char* const p3 = greeting;          // 常指针，指向字符数组变量
    const char* const p4 = greeting;    // 常指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常指针
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用: const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用: int* const p = function7();
```

## C++中指针和引用的区别

1. 本质: 指针是一个变量，存储内容是一个地址，指向内存的一个存储单元。而引用是原变量的一个别名，实质上和原变量是一个东西，是某块内存的别名。
2. 指针的值可以为空，且非const指针可以被重新赋值以指向另一个不同的对象。而引用的值不能为空，并且引用在定义的时候必须初始化，一旦初始化，就和原变量“绑定”，不能更改这个绑定关系。
3. 对指针执行sizeof()操作得到的是指针本身的大小（32位系统为4,64位系统为8）。而对引用执行sizeof()操作得到的是所绑定的对象的所占内存大小。
4. 指针的自增(++)运算表示对地址的自增，自增大小要看所指向单元的类型。而引用的自增(++)运算表示对值的自增。
5. 在作为函数参数进行传递时的区别: 指针所以函数传输作为传递时，函数内部的指针形参是指针实参的一个副本，改变指针形参并不能改变指针实参的值，通过解引用*运算符来更改指针所指向的内存单元里的数据。而引用在作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。

## 拷贝构造函数的参数类型必须是引用

- 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成`无穷递归地调用拷贝构造函数`。因此拷贝构造函数的参数必须是一个引用。
- 需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

在C++中，有下面三种对象需要拷贝的情况:

* 一个对象以值传递的方式传入函数体

* 一个对象以值传递的方式从函数返回

* 一个对象需要通过另外一个对象进行初始化

以上的情况就需要拷贝构造函数的调用。

当类中的数据成员需要动态分配存储空间时，不可以依赖default copy constructor。当default copy constructor被因编译器需要而合成时，将执行default bitwise copy语义。此时如果类中有动态分配的存储空间时，将会发生惨重的灾情。在需要时（包括这种对象要赋值、这种对象作为函数参数要传递、函数返回值为这种对象等情况），要考虑到自定义拷贝构造函数。

## 为什么内联函数，构造函数，静态成员函数不能为virtual函数？

1> 内联函数

内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数。

2> 构造函数

构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

3> 静态成员函数

静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别。

4> 友元函数

C++不支持友元函数的继承，对于没有继承性的函数没有虚函数

1. virtual意味着在执行时期进行绑定，所以在编译时刻需确定信息的不能为virtual。
2. virtual意味着派生类可以改写其动作。

https://github.com/klc407073648/interview#-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%BB%8F%E9%AA%8C
https://zhuanlan.zhihu.com/p/30996101

 
